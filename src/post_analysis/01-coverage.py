#!/usr/bin/python
import argparse 
import androlyze
import datetime
import time
import logging
import trace
import sys
import os
import re
import glob

from dynamic import SIMULATIONS

from collections import defaultdict

# Get the platform directories
ROOTDIR = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..')
if not os.path.exists( os.path.join(ROOTDIR, 'config.sh') ):
    ROOTDIR = os.path.join(ROOTDIR, '..')

DIR_APP = os.path.join(ROOTDIR, 'lib', 'apps')
DIR_IMG = os.path.join(ROOTDIR, 'lib', 'images')
DIR_AND = os.path.join(ROOTDIR, 'lib', 'android')
DIR_API = os.path.join(DIR_AND, 'apis')

# 1. get a list of all methods implemented by the APK (using static analysis: androguard)
# 2. get a list of all methods invoked during stimulation (using trace.py -> _parse_file_fast())
# 3. compute the code coverage

notfound = []
multiple = []

##
# Statically analyze an APK (using Androguard's androlyze) and generate a list
# of functions defined in this apk 
# @param    apk             The filename of the target APK
# @param    api_classes     A list of API class names
# @param    naive           If true, mechanically generated bytecode and
#                           classes that are in <api_classes> will be ignored.
#                           For the code coverage computation, this means that
#                           missing library calls will not be taken into
#                           consideration during computation. To test whether a
#                           defined function is an API or library function, a
#                           simple string compare on the class name is used. Be
#                           aware that an APK may overwrite these packages in
#                           which case it does make sense not to be naive.
# @return   A list of trace.Function() objects defined in <apk>
def get_apk_methods(apk, api_classes, naive = True, package = ''):

    apk_functions = []

    a, d, dx = androlyze.AnalyzeAPK(apk)
    package_name = str(a.package)

    for method in d.get_methods():
        class_name = method.class_name[1:len(method.class_name)-1].replace('/','.')
        method_name = method.name

        # get return type
        proto = method.get_descriptor()
        ret = proto.split(')')
        return_type = androlyze.get_type(ret[1])

        if method.code == None:
            # these are abstracts
            continue

        # get parameters
        nb = method.code.get_registers_size()

        parameters = []
        params = ret[0][1:].split()
        if params:
            j = 0
            for i in xrange(nb - len(params), nb):
                parameters.append( androlyze.get_type(params[j]) )
                j += 1
        
        # ignore resource constructors
        if method_name == '<init>' and (class_name == package_name + '.R' or class_name.startswith(package_name + '.R$')): continue

        if naive:
            # ignore mechanically generate bytecode
            if '$' in method_name: continue
            if '$' in class_name:  continue

            # ignore API bytecode
            if trace.is_api(class_name, api_classes): continue

            # limit search to only the provided package (if any)
            if package and not class_name.startswith(package): continue

        f = trace.Function()
        f.target_object = class_name
        f.name          = method_name
        f.return_type   = return_type
        f.parameters    = parameters
        f.called        = 0
        apk_functions.append(f)

#       print '%s %s.%s(%s)' % (return_type, class_name, method_name, parameters)


    return apk_functions, package_name


# Return the date as a number of seconds since EPOCH by converting lines like:
# '[2013-07-05 11:25:48,742   package.02-features.py] Populating API classes'
def parse_date(line):
    t = line.split('[')[1].split('  ')[0]
    return int( time.mktime( time.strptime(t, '%Y-%m-%d %H:%M:%S,%f') ) ) * 1000 * 1000
    
def get_simulations(logdir):
    started = {}

    f = open(os.path.join(logdir,'analysis.log'))
    for line in f:
        if 'Host - Guest = ' in line:
            delta = int(line.split()[-2])
    f.close()

    # We will be using the guest time as true time. The log timestamps are from the host, so substract the delta to
    # get the timestamp of the start of the simulation as it was for the emulator
    f = open(os.path.join(logdir,'analysis.log'))
    for line in f:
        for simulation in SIMULATIONS:
            if 'Looking at action: %s' % simulation in line: 
                date = parse_date(line) - delta
                started[date] = simulation

        # post analysis is always started after the emulator was closed and there shall thus no method trace line with a timestamp after this one
        if 'Starting post analysis' in line:
            date = parse_date(line) - delta
            started[date] = 'End'
    f.close()

    return started



##
# Parse method trace output files and generate a list of functions that were
# found during dynamic analysis
# @param    path                Path to the log directory
# @param    api_classes         A list of API class names. If timestamps are
#                               ignored, this list is used by the parser to
#                               remove API calls from the results.
# @param    ignore_timestamps   If True, the parser will ignore timestamps.
#                               This will increase the speed of the computation
#                               process. 
#                               If interval output is required, then this must
#                               be False.
# @param    package_name        Package name of the APK. Used to search for ANR mesesages.
# @param    logger              Logger
# @param    verbose             Verbose output (print progress)
# @return   A list of trace.Function() objects found during dynamic analysis.
def get_traced_methods(path, api_classes, ignore_timestamps, package_name, logger, verbose):
    
    # If the output directory contains one of these keywords, the traces will
    # be stored in the dictionary under this keyword. This is used to compute
    # code coverage per simulation effect. 
    keywords = SIMULATIONS

    # traces will become a dictionary of above keywords, plus 'complete'
    traces = defaultdict(list)

    traced = trace.Trace(api_classes = api_classes, logger = logger)

    dump_filename_parser = re.compile('^[a-zA-Z\.]*\.\d+\.\d+$')
    logc_filename_parser = re.compile('^logcat.log$')

    for dirpath, dirnames, filenames in os.walk(path):
        for filename in filenames:

            # search for logcat files
            groups = logc_filename_parser.search(filename)
            if groups:
                f = open(os.path.join(dirpath,filename))
                for line in f:
                    if 'threadExitUncaughtException()'     in line: logger.warning("#     Uncaught Exception: %s",line.strip())
                    if 'uncaught exception'                in line: logger.warning("#     Uncaught Exception: %s",line.strip())
                    if 'ANR in'   in line and package_name in line: logger.warning("#     ANR Detected: %s",line.strip())
                    if 'has died' in line and package_name in line: logger.warning('#     Died: %s',line.strip())
                    if 'code around pc'                    in line: logger.warning('#     VM Crashed')
                f.close()

            # search for method traces
            groups = dump_filename_parser.search(filename)
            if groups is None: continue

            logger.info("#     Parsing: %s" % filename)
            traced_functions = traced._parse_file_fast(os.path.join(dirpath,filename),              # path of trace file
                                                       ignore_timestamps    = ignore_timestamps,    # ignore timestamps (speedup)
                                                       verbose              = verbose)              # print progress output
            for keyword in keywords:
                if keyword in dirpath: traces[keyword] += traced_functions
            traces['complete'] += traced_functions

    return traces

##
# Provided two lists of functions, compute the code coverage
# @param    apk_functions       List of trace.Function() objects defined in the
#                               APK
# @param    traced_functions    List of trace.Function() objects found during
#                               dynamic analysis
# @param    api_classes         A list of API class names. If a function from
#                               <traced_functions> is an API call, we won't
#                               search for it in <apk_functions>
# @param    logger              Logger
# @param    verbose             Verbose output (print progress)
# @return   A tuple of number of hits, total number of functions found in the APK, and code coverage
def compute_coverage(apk_functions, traced_functions, api_classes, logger, verbose):
    total = len(traced_functions)
    prev  = 0

    for i, tf in enumerate(traced_functions):

        # only print progress in verbose mode to avoid bloated coverage log files
        if verbose: prev = trace.print_progress(logger, i, total, prev)

        # we assume that API methods won't be found inside the APK
        if trace.is_api(tf.target_object, api_classes): continue
#       if '$' in tf.target_object: continue
#       if '$' in tf.name: continue

        found = 0
        for af in apk_functions:

            if af.equals_signature(tf):
                af.called = af.called + 1
                found = found + 1

        if found == 0:
            # this is not really an issue probably...
            # add this method to the notfound list if it is not in there already
            if not [ x for x in notfound if x.equals_signature(tf) ]:
                logger.warning("#     No apk method found for traced method: %s" % tf)
                notfound.append(tf)
            
        if found > 1:
            # this would be weird
            # add this method to the multiple list if it is not in there already
            if not [ x for x in multiple if x.equals_signature(tf) ]:
                logger.warning("#     Multiple apk methods found for traced method: %s" % af)
                multiple.append(tf)

#   misses = sum([ x.called == 0 for x in apk_functions])
    hits   = sum([ x.called >  0 for x in apk_functions])
    total  = len(apk_functions)
    return hits, total, (100.0 / total) * hits

##
# Provided two lists of functions, get the code coverage (computing is done in
# compute_coverage).
# @param    apk_functions       List of trace.Function() objects defined in the
#                               APK
# @param    traced_functions    List of trace.Function() objects found during
#                               dynamic analysis
# @param    api_classes         A list of API class names. If a function from
#                               <traced_functions> is an API call, we won't
#                               search for it in <apk_functions>
# @param    interval            The interval used to print out the code
#                               coverage table. If 0, no table will be printed.
# @param    logger              Logger
# @param    verbose             Verbose output (print progress)
# @return   A tuple of number of hits, total number of functions found in the APK, and code coverage
def get_coverage(apk_functions, traced_functions, api_classes, interval, logdir, logger, verbose):
    
    if len(apk_functions) == 0:
        print 'no static functions found'
        return -1.0

    if len(traced_functions) == 0:
        print 'no traced functions found'
        return -1.0
    
    if interval > 0:
        started = get_simulations(logdir)
        min_time = min([x.timestamp for x in traced_functions])
        max_time = max([x.timestamp for x in traced_functions])

        first_simulation = min(k for k in started.keys())
        last_simulation  = max(k for k in started.keys())

        if min_time < first_simulation:
            logger.warning('First method trace line was printed before first simulation was started! Unreliable results coming up')

        if max_time > last_simulation:
            logger.warning('Last method trace line was printed after the emulator was closed! Unreliable results coming up!')


#       for tmp_time in xrange (min_time, max_time + interval, interval):
        for tmp_time in xrange (first_simulation, last_simulation, interval):
            tlist = [x for x in traced_functions if x.timestamp >= min_time and x.timestamp <= tmp_time]

            simulation_start = max(k for k in started.keys() if k <= tmp_time)
            simulation_name  = started[simulation_start]
            
            # probably not a good idea to show progress of code coverage computation for every interval
            hits, total, coverage = compute_coverage(apk_functions, tlist, api_classes, logger, verbose = False)
            logger.info('%16d: %5.02f%% (%d of %d. function calls: %d) %s' % ((tmp_time / 1000000), coverage, hits, total, len(tlist), simulation_name) )
    
    hits, total, coverage = compute_coverage(apk_functions, traced_functions, api_classes, logger, verbose)
  
#    for match in [x for x in apk_functions if x.called > 0]: 
#        if match.name == '<init>': print 'match: %s.%s(%s)'    % (                   match.target_object, match.name, match.parameters)
#        else:                      print 'match: %s %s.%s(%s)' % (match.return_type, match.target_object, match.name, match.parameters)
#    for miss in [x for x in apk_functions if x.called == 0]:
#        if miss.name == '<init>': print 'missed: %s.%s(%s)' % (miss.target_object, miss.name, miss.parameters)
#        else:                     print 'missed: %s.%s(%s)' % (miss.target_object, miss.name, miss.parameters)

    return hits, total, coverage

def get_logger(logdir, verbose, naive):
    # log filename
    if naive: 
#       log_filename = "coverage.naive." + str(datetime.datetime.now()).replace(' ','.').replace(':','.')
        log_filename = 'coverage.naive.log'
    else: 
#       log_filename = "coverage.conservative." + str(datetime.datetime.now()).replace(' ','.').replace(':','.')
        log_filename = 'coverage.conservative.log'

    # file log format
    formatter = logging.Formatter("")

    # root logger that handles every message.
    logger = logging.getLogger('coverage')
    logger.setLevel(logging.DEBUG)

    # file logger
    fileLogger = logging.FileHandler(filename = os.path.join(logdir, log_filename))
    fileLogger.setFormatter(formatter)
    fileLogger.setLevel(logging.INFO)
    logger.addHandler(fileLogger)

    if verbose:
        # console logger that handles messages to <level>.
        consoleLogger = logging.StreamHandler()
        
        # console log format
        formatter = logging.Formatter("%(asctime)-6s: %(name)s - %(message)s")

        consoleLogger.setFormatter(formatter)
        consoleLogger.setLevel(logging.INFO)
        logger.addHandler(consoleLogger)

    return logger, fileLogger


def main(apk = None, logdir = None, verbose = False, interval = 0, naive = False, package = ''):
    if not apk or not logdir:
        parser = argparse.ArgumentParser(description="Get the code coverage of a given .APK and its log directory, FAST.")
        parser.add_argument("--input",     action="store",     required=True, help="Android package (.apk) that was analyzed") 
        parser.add_argument("--logdir",    action="store",     required=True, help="Log directory")
        parser.add_argument("--verbose",   action="store_true",required=False,default=False,help="Verbose output")
        parser.add_argument("--interval",  action="store",     required=False,default=0,    help="Interval used for coverage table in seconds. By default, no coverage table will be generated (faster)")
        parser.add_argument("--naive",action="store_true",required=False,default=False,help="Be naive during code coverage computation (i.e. exclude known libraries and api functions from apk")
        parser.add_argument("--package",action="store", required=False,default='',help="limit coverage to this package name only")
        args     = parser.parse_args() 
        apk      = args.input
        logdir   = args.logdir
        verbose  = args.verbose
        interval = args.interval
        naive    = args.naive
        package  = args.package
 

    if not os.path.exists(apk):
        print "Input %s does not exist" % apk 
        sys.exit()

    if not os.path.exists(logdir):
        print "Logdir %s does not exist" % logdir
        sys.exit()

    if interval == 0: ignore_timestamps = True
    else:             ignore_timestamps = False

    logger, filelogger = get_logger(logdir, verbose, naive)
    

    if naive: apis = glob.glob( os.path.join(DIR_API, '*.jar') )
    else:     apis = [ os.path.join( DIR_API, 'android-10.jar') ]
    
    api_classes = trace.load_api(apis)

    if naive: logger.info('# naive')

    logger.info('# -> Running static analysis')
    apk_functions, package_name = get_apk_methods(apk, api_classes, naive, package)

    if len(apk_functions) == 0:
        print 'No methods found in apk'
        sys.exit()

    logger.info('# -> Parsing method traces')
    traces = get_traced_methods(logdir, 
                                api_classes, 
                                ignore_timestamps, 
                                package_name,
                                logger, 
                                verbose)

    for keyword, traced_functions in traces.iteritems():
        if len(traced_functions) > 0:
            for af in apk_functions:
                af.called = 0

            logger.info('# -> Computing code coverage for %s' % keyword)
            hits, total, coverage = get_coverage(apk_functions, traced_functions, api_classes, int(interval) * 1000000, logdir, logger, verbose)
            
            if naive: logger.info('# -> Code coverage: %15.10f%% (%8d of %8d) (naive)        (%s)' % (coverage, hits, total, keyword))
            else:     logger.info('# -> Code coverage: %15.10f%% (%8d of %8d) (conservative) (%s)' % (coverage, hits, total, keyword))

            if naive: print '%15.10f (naive)        (%s)' % (coverage, keyword)
            else:     print '%15.10f (conservative) (%s)' % (coverage, keyword)

    for handler in list(logger.handlers):
        logger.removeHandler(handler)
        handler.flush()
        handler.close()
    logging.shutdown()

def post_analysis(apk, logbase, static_analysis, logger):
#   main(apk = apk, logdir = logbase, naive = False)
    main(apk = apk, logdir = logbase, naive = True)

if __name__ == "__main__":
    main()

